<?php

/**
 * @file
 * Provide pgp encryption for files.
 */

require_once 'inc/proc.functions.inc';

/**
 * Implements hook_permission().
 */
function proc_permission() {
  return [
    'register protected content keys' => [
      'title' => t('Register protected content keys'),
      'description' => t('Allow user to access Protected Content Keys registration page.'),
    ],
    'new protected file' => [
      'title' => t('Create new protected file'),
      'description' => t('Allow user to access Create New Protected File page.'),
    ],
    'create cipher' => [
      'title' => t('Create new cipher'),
      'description' => t('Allow user to create new cipher entity.'),
    ],
    'view cipher' => [
      'title' => t('View cipher'),
      'description' => t('Allow user to view cipher entity.'),
    ],
    'delete cipher' => [
      'title' => t('Delete cipher'),
      'description' => t('Allow user to delete cipher entity.'),
    ],
    'update cipher' => [
      'title' => t('Edit cipher'),
      'description' => t('Allow user to update cipher entity.'),
    ],
  ];
}

/**
 * Implements hook_help().
 */
function proc_help($path) {
  switch ($path) {
    case "admin/help#proc":
      return '<p>' . t('Protected Content (proc) provides end-to-end/client side encryption for content.') . '</p>';
  }
}

/**
 * Implements hook_menu().
 */
function proc_menu() {

  $items['proc/keyring/add'] = [
    'title' => 'Manage Encryption Keys',
    'page callback' => 'drupal_get_form',
    'page arguments' => ['_proc_generate_keys'],
    'access arguments' => ['register protected content keys'],
    'type' => MENU_LOCAL_TASK,
    'file' => 'inc/proc.forms.inc',
  ];
  $items['proc/add/%/%'] = [  
    'title' => 'Add content',
    'page callback' => 'drupal_get_form',
    'page arguments' => ['_proc_encrypt', 2, 3],
    'access arguments' => ['new protected file'],
    'type' => MENU_LOCAL_TASK,
    'file' => 'inc/proc.forms.inc',
  ];
  $items['proc/add/%'] = [
    'title' => 'Add content',
    'page callback' => 'drupal_get_form',
    'page arguments' => ['_proc_encrypt', 2],
    'access arguments' => ['new protected file'],
    'type' => MENU_LOCAL_TASK,
    'file' => 'inc/proc.forms.inc',
  ];
  $items['proc/%'] = [
    'title' => 'View Protected Content',
    'page callback' => 'drupal_get_form',
    'page arguments' => ['_proc_decrypt', 1],
    'access callback' => '_proc_recipient_multiple',
    'access arguments' => [1],
    'type' => MENU_LOCAL_TASK,
    'file' => 'inc/proc.forms.inc',
  ];
  $items['proc/update/%/%'] = [
    'title' => 'Update Protected Content',
    'page callback' => 'drupal_get_form',
    'page arguments' => ['_proc_update', 2, 3],
    'access callback' => '_proc_recipient_multiple',
    'access arguments' => [2],
    'type' => MENU_LOCAL_TASK,
    'file' => 'inc/proc.forms.inc',
  ];
  $items['proc/api/get/%'] = [
    'title' => 'Get Protected Content',
    'page callback' => '_proc_get_proc_menu_callback',
    'page arguments' => [3],
    'access callback' => '_proc_recipient',
    'access arguments' => [3],
    'file' => 'inc/proc.functions.inc',
  ];
  $items['proc/api/getpubkey/%/%'] = [
    'title' => 'Get Public Key',
    'page callback' => '_proc_get_pubkey_menu_callback',
    'page arguments' => [3, 4],
    'access arguments' => ['new protected file'],
    'file' => 'inc/proc.functions.inc',
  ];
  $items['proc/sign/%'] = [
    'title' => 'Sign a file',
    'page callback' => 'drupal_get_form',
    'page arguments' => ['_proc_sign_file', 2],
    'access arguments' => ['new protected file'],
    'type' => MENU_LOCAL_TASK,
    'file' => 'inc/proc.forms.inc',
  ];
  return $items;
}

/**
 * Implements hook_views_api().
 */
function proc_views_api() {
  return [
    'api' => '3.0',
    'path' => drupal_get_path('module', 'proc') . '/inc',
  ];
}

/**
 * Implements hook_libraries_info().
 */
function proc_libraries_info() {
  $libs = [];

  $crypto_info = _proc_get_cryptolib_settings();

  $libs[$crypto_info['folder']] = [
    'name' => $crypto_info['versionstring'],
    'vendor url' => $crypto_info['vendor'],
    'download url' => $crypto_info['url'],
    'version arguments' => [
      'file' => $crypto_info['file'],
      'pattern' => '/v(([0-9]\.?)+)/',
      'lines' => 1,
      'cols' => 24,
    ],
    'files' => [
      'js' => [$crypto_info['file']],
    ],
  ];

  return $libs;
}

/**
 * Implements hook_entity_info().
 */
function proc_entity_info() {
  $info = [
    'proc' => [
      'label' => t('Protected Content'),
      'entity class' => 'Proc',
      'base table' => 'proc',
      'label callback' => 'entity_class_label',
      'uri callback' => 'entity_class_uri',
      'entity keys' => [
        'id' => 'pid',
        'bundle' => 'type',
      ],
      'bundle keys' => [
        'bundle' => 'type',
      ],
      'bundles' => [
        'proc_keyring' => [
          'label' => t('Keyring'),
        ],
        'proc_ciphertxt' => [
          'label' => t('Ciphertext'),
        ],
      ],
      'view modes' => [
        'full' => [
          'label' => t('Default'),
          'custom settings' => FALSE,
        ],
      ],
      'module' => 'proc',
      'access callback' => 'proc_access',
      'controller class' => 'EntityAPIController',
      'metadata controller class' => '',
      'fieldable' => TRUE,
      'views controller class' => 'EntityDefaultViewsController',
    ],
  ];
  return $info;
}

/**
 * Implements hook_entity_property_info().
 *
 * It is not necessary to describe metadata for fields created with
 * field_create_instance function. Metadata for these fields is
 * created automatically.
 */
function proc_entity_property_info() {
  $info = [];
  // $properties = &$info['proc']['properties'];
  $properties = $info['proc']['properties'];

  $properties['pid'] = [
    'type' => 'integer',
    'schema field' => 'pid',
    'label' => t('Proc Armored entity ID'),
    'setter callback' => 'entity_property_verbatim_set',
  ];
  $properties['type'] = [
    'type' => 'text',
    'schema field' => 'type',
    'required' => TRUE,
    'label' => t('Proc Armored entity type (bundle)'),
    'setter callback' => 'entity_property_verbatim_set',
  ];
  $properties['uid'] = [
    'type' => 'user',
    'schema field' => 'uid',
    'required' => TRUE,
    'label' => t('Proc Armored author'),
    'setter callback' => 'entity_property_verbatim_set',
  ];
  $properties['label'] = [
    'type'  => 'text',
    'schema field' => 'label',
    'required' => TRUE,
    'label' => t('Protected content label'),
    'description' => t('Friendly identifier for armored data'),
    'setter callback' => 'entity_property_verbatim_set',
  ];
  $properties['status'] = [
    'type' => 'boolean',
    'schema field' => 'status',
    'label' => t('Proc Armored entity status'),
    'setter callback' => 'entity_property_verbatim_set',
  ];
  $properties['created'] = [
    'type' => 'date',
    'schema field' => 'created',
    'required' => TRUE,
    'label' => t('Proc Armored created timestamp'),
    'setter callback' => 'entity_property_verbatim_set',
  ];
  $properties['changed'] = [
    'type' => 'date',
    'schema field' => 'changed',
    'required' => TRUE,
    'label' => t('Proc Armored changed timestamp'),
    'setter callback' => 'entity_property_verbatim_set',
  ];
  $properties['meta'] = [
    'type'  => 'text',
    'schema field' => 'meta',
    'required' => TRUE,
    'label' => t('Protected content metadata'),
    'description' => t('Metadata generated on cipher creation'),
    'setter callback' => 'entity_property_verbatim_set',
  ];
  return $info;
}

/**
 * Proc class.
 */
class Proc extends Entity {

  /**
   * Defualt URI.
   */
  protected function defaultUri() {
    if (($this->type == 'proc_ciphertxt') && (_proc_recipient($this->identifier()))) {
      return ['path' => 'proc/' . $this->identifier()];
    }
    return FALSE;
  }

  /**
   * Default label.
   */
  protected function defaultLabel() {
    return $this->label;
  }
}

/**
 * Access callback for Proc.
 */
function proc_access($op, $task, $account = NULL, $entity_type = NULL) {
  global $user;

  if (!isset($account)) {
    $account = $user;
  }
  switch ($op) {
    case 'create':
      return user_access('create cipher', $account);

    case 'view':
      return user_access('view cipher', $account);

    case 'delete':
      return user_access('delete cipher', $account);

    case 'update':
      return user_access('update cipher', $account);
  }
}

/**
 * Implements hook_entity_update().
 */
function proc_entity_update($entity, $type){
  if (isset($entity->changed) && $type == 'proc'){
    if ($entity->changed > $entity->original->changed){
      module_invoke_all('cipher_update_postsave', $entity, $type);
      $success_update_message = t(
        'File %file_label (%file_id) updated successfully for %number_recipients user(s)',
        [
          '%file_label' => $entity->label,
          '%file_id' => $entity->pid,
          '%number_recipients' => count($entity->proc_recipient[LANGUAGE_NONE]),
        ]
      );
      drupal_set_message($success_update_message);
    }
  }
}

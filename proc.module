<?php

/**
 * @file
 * Provide pgp encryption for files.
 */

/**
 * Implements hook_permission().
 */
function proc_permission() {
  return array(
    'register protected content keys' => array(
      'title' => t('Register Protected Content Keys'),
      'description' => t('Allow user to access Protected Content Keys registration page.'),
    ),
    'new protected file' => array(
      'title' => t('Create new Protected File'),
      'description' => t('Allow user to access Create New Protected File page.'),
    ),
  );
}

/**
 * Implements hook_help().
 */
function proc_help($path) {
  switch ($path) {
    case "admin/help#proc":
      return '<p>' . t('Protected Content (proc) provides end-to-end/client side encryption for content.') . '</p>';
  }
}

/**
 * Implements hook_menu().
 */
function proc_menu() {

  // @TODO: replace by protected-content/key-pair/add
  $items['protected-content/key-pair/new'] = array(
    'title' => 'Add Protected Content Key',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('_proc_generate_keys'),
    'access arguments' => array('register protected content keys'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'inc/proc.forms.inc',
  );
  // @TODO: replace by protected-content/cipher/<uid/s>/add
  $items['protected-content/file/new/%'] = array(
    'title' => 'Add file',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('_proc_encrypt_file', 3),
    'access arguments' => array('new protected file'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'inc/proc.forms.inc',
  );
  // @TODO: replace by protected-content/cipher/<cid>/view
  $items['protected-content/file/open/%'] = array(
    'title' => 'View Protected Content',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('_proc_decrypt_to_file', 3),
    'access callback' => '_proc_recipient',
    'access arguments' => array(3),
    'type' => MENU_LOCAL_TASK,
    'file' => 'inc/proc.forms.inc',
  );
  return $items;
}

/**
 * Helper to load the cryptoigraphic library settings from info file.
 */
function _proc_get_cryptolib_settings() {
  $crypto_lib_settings = array();

  $path = drupal_get_path('module', 'proc') . '/proc.info';
  $info = drupal_parse_info_file($path);
  $crypto_lib_settings['versionstring'] = $info['crypto_library_versionstring'];
  $crypto_lib_settings['url'] = $info['crypto_library_url'];
  $crypto_lib_settings['folder'] = $info['crypto_library_folder'];
  $crypto_lib_settings['vendor'] = $info['crypto_library_vendor'];
  $crypto_lib_settings['file'] = $info['crypto_library_file'];

  return $crypto_lib_settings;
}

/**
 * Implements hook_views_api().
 */
function proc_views_api() {
  return array(
    'api' => '3.0',
    'path' => drupal_get_path('module', 'proc') . '/inc',
  );
}

/**
 * Helper to load the library.
 */
function _proc_lib_load() {
  if (function_exists('libraries_load')) {
    $lib = libraries_load(_proc_get_cryptolib_settings()['folder']);
  }
  return $lib;
}

/**
 * Helper function to get proc_keys data.
 */
function _proc_get_keys($user_id) {

  $result = db_select('proc_keys', 'er')
    ->fields('er', ['encrypted_private_key', 'uid', 'kid', 'public_key'])
    ->condition('uid', $user_id, '=')
    ->orderBy('kid', 'DESC')
    ->execute()
    ->fetchAll();

  return $result;
}

/**
 * Helper function to get given cipher text that belongs to current user.
 */
function _proc_get_cipher($cid) {
  global $user;

  $result = db_select('proc_cipher_texts', 'ci')
    ->fields('ci', [
      'cid',
      'recipient_uid',
      'cipher_text',
      'source_file_name',
      'source_file_size',
      'recipients_uids',
    ])
    ->condition('recipients_uids', '%"' . db_like($user->uid) . '"%', 'LIKE')
    ->condition('cid', $cid, '=')
    ->range(0, 1)
    ->execute()
    ->fetchAll();

  return $result;
}

/**
 * Helper function to check if current user is recipient of cipher text.
 */
function _proc_recipient($cid) {
  global $user;

  if (isset($cid) && is_numeric($cid)) {
    $cid = (int) $cid;
    $cipher = _proc_get_cipher($cid);
    // @TODO: add 'bypass cipher access control' restricted permission
    if (!empty($cipher) or ($user->uid == 1)) {
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * Implements hook_libraries_info().
 */
function proc_libraries_info() {
  $libs = array();

  $crypto_info = _proc_get_cryptolib_settings();

  $libs[$crypto_info['folder']] = array(
    'name' => $crypto_info['versionstring'],
    'vendor url' => $crypto_info['vendor'],
    'download url' => $crypto_info['url'],
    'version arguments' => array(
      'file' => $crypto_info['file'],
      'pattern' => '/v(([0-9]\.?)+)/',
      'lines' => 1,
      'cols' => 24,
    ),
    'files' => array(
      'js' => array($crypto_info['file']),
    ),
  );

  return $libs;
}

/**
 * Implements hook_entity_info().
 */
function proc_entity_info() {
  $info = array(
    'proc' => array(
      'label' => t('Armored Proc'),
      'base table' => 'proc',
      'entity keys' => array(
        'id' => 'pid',
        // Database field where bundle types of entities are saved.
        'bundle' => 'type',
      ),
      // Describe which property of entity object shall be used to
      // identify entity bundle.
      'bundle keys' => array(
        'bundle' => 'type',
      ),
      // Describe bundles of this entity.
      'bundles' => array(
        'proc_keyring' => array(
          'label' => t('Proc Keyring'),
        ),
        'proc_ciphertxt' => array(
          'label' => t('Proc Cipher Text'),
        ),
      ),
      'entity class' => 'Entity',
      'controller class' => 'EntityAPIController',
      'metadata controller class' => '',
      // Is it possible to attach fields to bundles.
      'fieldable' => TRUE,
    ),
  );
  return $info;
}

/**
 * Implements hook_entity_property_info().
 * 
 * It is not necessary to describe metadata for fields created with 
 * field_create_instance function. Metadata for these fields is
 * created automatically.
 */
function proc_entity_property_info() {
  $info = array();
  $properties = &$info['proc']['properties'];
  $properties['pid'] = array(
    'type' => 'integer',
    'schema field' => 'pid',
    'label' => t('Proc Armored entity ID'),
    'setter callback' => 'entity_property_verbatim_set',
  );
  $properties['type'] = array(
    'type' => 'text',
    'schema field' => 'type',
    'required' => TRUE,
    'label' => t('Proc Armored entity type (bundle)'),
    'setter callback' => 'entity_property_verbatim_set',
  );
  $properties['uid'] = array(
    'type' => 'integer',
    'schema field' => 'uid',
    'required' => TRUE,
    'label' => t('Proc Armored author'),
    'setter callback' => 'entity_property_verbatim_set',
  );
  $properties['created'] = array(
    'type' => 'integer',
    'schema field' => 'created',
    'required' => TRUE,
    'label' => t('Proc Armored created timestamp'),
    'setter callback' => 'entity_property_verbatim_set',
  );

  // $properties['title'] = array(
  //   'type' => 'text',
  //   'schema field' => 'title',
  //   'required' => TRUE,
  //   'label' => t('Proc Armored entity title'),
  //   'setter callback' => 'entity_property_verbatim_set',
  // );
  // $properties['description'] = array(
  //   'type' => 'text',
  //   'schema field' => 'description',
  //   'label' => t('Proc Armored entity description'),
  //   'setter callback' => 'entity_property_verbatim_set',
  // );
  return $info;
}

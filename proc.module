<?php
/**
 * @file
 * Primary module hooks for Protected Content module.
 */

require_once 'inc/proc.functions.inc';

 /**
 * Implements hook_form_alter().
 */
function proc_form_proc_keys_generation_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) {
  $proc_data = _proc_common_get_decryption_form_data(NULL);

  $config = \Drupal::config('proc.settings');
  $key_size = $config->get('proc-rsa-key-size');

  $form['#attached'] = [
    'library' => [
      0 => 'proc/openpgpjs',
      1 => 'proc/proc-generate-keys',
    ],
    'drupalSettings' => [
      'proc' => [
        'proc_labels'   => _proc_js_labels(),
        'proc_data'     => $proc_data,
        'proc_key_size' => $key_size,
      ]
    ],
  ];

  $form['#action'] = 'generate-keys';
}

/**
* Implements hook_form_alter().
*/
function proc_form_proc_encrypt_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) {

  $proc_data = _proc_common_get_decryption_form_data(NULL);

  $config = \Drupal::config('proc.settings');
  $max_file_size = $config->get('proc-file-entity-max-filesize');
  if (empty($max_file_size)) {
    // Use 10M if no value is set.
    $max_file_size = 10000000;
  }

  $current_path = \Drupal::service('path.current')->getPath();

  $query_params = \Drupal::request()->query->all();
  $destination = FALSE;
  if (isset($query_params['destination'])) {
    $destination = $query_params['destination'];
  }

  $path_array = explode('/', $current_path);
  $selected_user_ids = explode(',', $path_array[3]);

  // Given a user ID, get the creation date of its
  // newwest encryption key.
  $proc_ids = [];
  foreach ($selected_user_ids as $user_id) {
    $query = \Drupal::entityQuery('proc')
      ->accessCheck(TRUE)
      ->condition('user_id', $user_id)
      ->condition('type', 'keyring')
      ->sort('id', 'DESC')
      ->range(0, 1);
    $proc_ids[$user_id] = key($query->execute());
  }

  $created = [];
  foreach ($proc_ids as $user_id => $proc_id) {
    // Get the creation data of the proc ID:
    $proc = \Drupal\proc\Entity\Proc::load($proc_id);
    if ($proc) {
      $created[$user_id] = $proc->get('created')->getValue()[0]['value'];
    }
    else {
      $created[1] = 1;
    }
  }

  $settings = [
    'proc_labels' => _proc_js_labels(),
    'proc_data'   => $proc_data,
    // @todo: turn this into a configuration:
    'proc_file_entity_max_filesize' => $max_file_size,
    'proc_post_max_size_bytes' => _proc_get_post_max_size_bytes(),
    'proc_recipients_pubkeys_changed' => json_encode($created),
    'basePath' => base_path(),
  ];
  $settings += $form['#attached']['drupalSettings']['proc'];

  $form['#attached'] = [
    'library' => [
      0 => 'proc/openpgpjs',
      1 => 'proc/proc-encrypt',
    ],
    'drupalSettings' => $settings,
  ];

  $current_path = substr($current_path, 1);
  $form_state->set('storage', $selected_user_ids);
  $form['#action'] = base_path() . $current_path;

  if ($destination) {
    $form['#action'] = base_path() . $destination;
  }
}

/**
 * Implements hook_entity_bundle_info_alter().
 */
function proc_entity_bundle_info_alter(array &$bundles): void {
  if (isset($bundles['proc']['proc'])) {
    $bundles['proc']['cipher']['class'] = \Drupal\proc\Entity\Bundle\ProcCipherTextBundle::class;
  }
}

// use Drupal\Core\Field\BaseFieldDefinition;
// use Drupal\Core\Entity\EntityTypeInterface;

/**
 * Implements hook_entity_base_field_info().
 */
// function proc_entity_base_field_info(EntityTypeInterface $entity_type) {
//   // if ($entity_type->id() === 'proc_type' || $entity_type->id() === 'proc') {
//   //   $fields['path'] = BaseFieldDefinition::create('path')
//   //     ->setLabel(t('The path alias'))
//   //     ->setComputed(TRUE);

//   //   return $fields;
//   // }
// }

/**
 * Implements hook_entity_bundle_field_info().
 */
function proc_entity_bundle_field_info(\Drupal\Core\Entity\EntityTypeInterface $entity_type, $bundle, array $base_field_definitions) {
  // if ($entity_type->isFieldable()) {
  //   // Configurable fields, which are always attached to a specific bundle, are
  //   // added 'by bundle'.
  //   return Field::fieldInfo()->getBundleInstances($entity_type->id(), $bundle);
  // }
  // return $entity_type->Field::fieldInfo()->getBundleInstances($entity_type->id(), $bundle);
}

/**
* Implements hook_form_alter().
*/
function proc_form_proc_decrypt_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) {
  // Get cipher IDs from the URL:
  $current_path = \Drupal::service('path.current')->getPath();
  $path_array = explode('/', $current_path);
  $cipher_ids_csv = $path_array[2];
  $cids = _proc_get_csv_argument($cipher_ids_csv);
  // Get
  $ciphers_data = _proc_common_get_ciphers($cids, FALSE);

  // Decryption requires a keyring:
  if (empty($ciphers_data['pubkey'])) {
    \Drupal\proc\Form\ProcDecryptForm::denyAccess();
  }

  $common_data = _proc_common_get_decryption_form_data($ciphers_data['privkey']);

  $ciphers_changed = [];
  $files_names = [];
  $files_sizes = [];
  foreach($ciphers_data['ciphers'] as $cipher_id_data) {
    $ciphers_changed[] = $cipher_id_data['changed'];
    $files_names[] = $cipher_id_data['source_file_name'];
    $files_sizes[] = $cipher_id_data['source_file_size'];
    // For diferenciating files from text areas:
    if (isset($cipher_id_data['source_input_mode'])) {
      $sources_input_mode[] = $cipher_id_data['source_input_mode'];
    }
    else {
      $sources_input_mode[] = 0;
    }
    //$sources_signed[] = $cipher_id_data['signed'];
    $sources_signed[] = 0;

  }


  $form['#attached'] = [
    'library' => [
      0 => 'proc/openpgpjs',
      1 => 'proc/proc-decrypt',
    ],
    'drupalSettings' => [
      'proc' => [
        'proc_labels'              => _proc_js_labels(),
        'proc_pass'                => $common_data['proc_pass'],
        // 'proc_data'                => $ciphers_data,
        'proc_privkey'             => $ciphers_data['privkey'],
        'proc_ids'                 => array_keys($ciphers_data['ciphers']),
        'procs_changed'            => $ciphers_changed,
        // Also used for labels on text area encryption:
        'proc_sources_file_names'  => $files_names,
        'proc_sources_file_sizes'  => $files_sizes,
        'proc_sources_input_modes' => $sources_input_mode,
        'proc_sources_signed'      => $sources_signed,
        // @TODO: get this from configuration:
        'proc_skip_size_mismatch'  => 'TRUE',
        'base_path'                => base_path(),
        'proc_signed'              => $sources_signed,
      ]
    ],
  ];
}

/**
* Implements hook_form_alter().
*/
function proc_form_proc_update_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) {

  $current_path = \Drupal::service('path.current')->getPath();
  $path_array = explode('/', $current_path);

  // Sanitize and preprocess arguments:
  $csvs = _proc_get_csv_arguments([
    'cids_csv' => $path_array[3],
    'uids_csv' => $path_array[4],
  ]);

  if (is_numeric($csvs['uids_csv']['array'][0])) {
    $action_path = base_path() . substr($current_path, 1);
    $form['#action'] = $action_path;
    // There is at least one user ID and therefore updated did not happen yet:
    $uids     = $csvs['uids_csv']['array'];
    $uids_csv = $csvs['uids_csv']['string'];
    $cids     = $csvs['cids_csv']['array'];
    $cids_csv = $csvs['cids_csv']['string'];

    $ciphers_data = _proc_common_get_ciphers($cids);

    // Updating requires a keyring:
    if (!$ciphers_data['pubkey']) {
      \Drupal\proc\Form\ProcDecryptForm::denyAccess();
    }

    $privkey      = $ciphers_data['privkey'];
    $cid_cipher   = $ciphers_data['ciphers'];
    $form['pass'] = _proc_common_get_decryption_form_data(NULL)['proc_pass'];

    // If some recipient is being removed of some content, allow update to proceed
    // only if current user is also the author of the content:
    $recipients = [];

    foreach ($ciphers_data['ciphers'] as $cipher_data) {
      if ($cipher_data['proc_owner_uid'] != $user->uid) {
        // Current recipients:
        foreach ($cipher_data['proc_recipients'] as $recipient) {
          $recipients[] = $recipient;
        }
      }
    }
    if (!empty($recipients)) {
      $all_current_recipients = array_unique($recipients);
      // $context = [
      //   'unalterable_recipient_uids' => $uids,
      // ];
      // drupal_alter('cipher_update_owner_check', $all_current_recipients, $context);

      if (array_diff($all_current_recipients, $uids)) {
        \Drupal\proc\Form\ProcDecryptForm::denyAccess();
      }
    }

    $pubkeys_data        = _proc_common_get_pubkeys($uids);
    $recipients_pubkeys  = $pubkeys_data['recipients_pubkeys'];
    $post_max_size_bytes = $pubkeys_data['post_max_size_bytes'];

    $pubkeys = [];
    foreach ($recipients_pubkeys as $recipient_pubkey) {
      $pubkeys[] = ['key' => $recipient_pubkey['key'], 'changed' => "0"];
    }


    $armored_ciphers = [];
    foreach ($cids as $cid) {
      $armored_ciphers[$cid] = _proc_get_cipher($cid, NULL, NULL, FALSE);

    }


    $encryption_form_elements = [
      'proc_ciphers'             => $cid_cipher,
      'proc_ciphers_index'       => $cids,
      'proc_recipients_pubkeys'  => \Drupal\Component\Serialization\Json::encode($pubkeys),
      'proc_post_max_size_bytes' => $post_max_size_bytes,
    ];


    $proc_data = _proc_common_get_decryption_form_data($privkey);



    $proc_data = $proc_data + $encryption_form_elements;

    $form['#attached'] = [
      'library' => [
        0 => 'proc/openpgpjs',
        1 => 'proc/proc-update',
      ],
      'drupalSettings' => [
        'proc' => [
          'proc_labels' => _proc_js_labels(),
          'proc_data'   => $proc_data,
        ]
      ],
    ];

    $update_field_form_elemement_prefixes = [
      'cipher_text_cid_',
      'generation_timestamp_cid_',
      'generation_timespan_cid_',
      'browser_fingerprint_cid_',
      'source_file_name_cid_',
      'source_file_size_cid_',
      'source_file_type_cid_',
      'source_file_last_change_cid_',
    ];


    foreach ($cids as $cid) {
      foreach ($update_field_form_elemement_prefixes as $update_field_form_elemement_prefix) {
        $form[$update_field_form_elemement_prefix . $cid] = ['#type' => 'hidden'];
      }
    }
  }
  else {
    // Updating has already happened:
  }

  // $form['#action'] = base_path() . $current_path;

}

/**
 * Implements hook_field_info().
 */
// function proc_field_info_alter(&$info) {
//   return [
//     'proc_entity_reference_field' => [
//       'label' => t('Proc Entity Reference Field'),
//       'description' => t('A custom entity reference field.'),
//       'settings' => [
//         'target_type' => 'proc',
//         'handler' => 'default',
//       ],
//       'instance_settings' => [
//         'target_bundles' => [],
//       ],
//       'default_widget' => 'options_select',
//       'default_formatter' => 'entity_reference_label',
//     ],
//   ];
// }

// /**
// * Implements hook_field_schema().
// */
// function proc_field_schema_alter($field) {
//   $schema = array(
//     'columns' => array(
//       'target_id' => array(
//         'type' => 'int',
//         'unsigned' => TRUE,
//         'not null' => FALSE,
//       ),
//     ),
//     'indexes' => array(
//       'target_id' => array('target_id'),
//     ),
//   );

//   return $schema;
// }

/**
 * Implements hook_theme().
 */
function proc_theme($existing, $type, $theme, $path) {
  return [
    'proc_template' => [
      'variables' => [
        'linkTitle' => '',
        'elementSettings' => NULL,
        'elementClasses' => NULL,
        'elementAttributes' => NULL,
      ],
    ],
  ];
}

function proc_field_widget_single_element_form_alter(array &$element, \Drupal\Core\Form\FormStateInterface $form_state, array $context) {

  // ksm('here');
  // Add a css class to widget form elements for all fields of type my_type.
  $field_definition = $context['items']->getFieldDefinition();


  if ($field_definition->getType() == 'proc_entity_reference_field') {
    // ksm('bla');
    // ksm($element);
    // var_dump($context);

  }
}

function hook_field_widget_single_element_proc_entity_reference_field_form_alter(array &$element, \Drupal\Core\Form\FormStateInterface $form_state, array $context) {
  // ksm('here');
  // Code here will only act on widgets of type WIDGET_TYPE.  For example,
  // hook_field_widget_single_element_mymodule_autocomplete_form_alter() will
  // only act on widgets of type 'mymodule_autocomplete'.
  // $element['#autocomplete_route_name'] = 'mymodule.autocomplete_route';
}

/**
 * Implements hook_library_info_build().
 */
function proc_library_info_build() {
  $libraries['proc'] = [
    'version' => '1.x',
    'js' => [
      'js/proc-field.js' => [],
    ],
  ];

  return $libraries;
}



/**
 * Implements hook_form_alter().
 */
function proc_form_field_storage_config_edit_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id): void {

  if (isset($form['settings']['target_type']) && $form['settings']['target_type']['#default_value'] === 'proc') {
    $form['settings']['target_type']['#disabled'] = TRUE;
  }

}

function proc_form_field_config_edit_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) {
}

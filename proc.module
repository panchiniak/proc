<?php
/**
 * @file
 * Primary module hooks for Protected Content module.
 */

require_once 'inc/proc.functions.inc';

 /**
 * Implements hook_form_alter().
 */
function proc_form_proc_keys_generation_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) {
  $proc_data = _proc_common_get_decryption_form_data(NULL);

  $form['#attached'] = [
    'library' => [
      0 => 'proc/openpgpjs',
      1 => 'proc/proc-generate-keys',
    ],
    'drupalSettings' => [
      'proc' => [
        'proc_labels' => _proc_js_labels(),
        'proc_data'   => $proc_data, 
      ]
    ],
  ];

  $form['#action'] = 'generate-keys';
  // $path_service = \Drupal::service('redirect.destination')->getAsArray()['destination'];
  // if ($path_service) {
  //   $form['#action'] = $path_service;  
  // }
}

/**
* Implements hook_form_alter().
*/
function proc_form_proc_encrypt_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) {
  $proc_data = _proc_common_get_decryption_form_data(NULL);

  $current_path = \Drupal::service('path.current')->getPath();
  $path_array = explode('/', $current_path);

  // ksm($path_array[3]);
  $selected_user_ids = explode(',', $path_array[3]);

  // Given a user ID, get the creation date of its 
  // newwest encryption key.
  $proc_ids = [];
  foreach ($selected_user_ids as $user_id) {
    $query = \Drupal::entityQuery('proc')
      ->condition('user_id', $user_id)
      ->condition('type', 'keyring')
      ->sort('id', 'DESC')
      ->range(0, 1);
    $proc_ids[$user_id] = key($query->execute());
  }

  $created = [];
  foreach ($proc_ids as $user_id => $proc_id) {
    // Get the creation data of the proc ID:
    $proc = \Drupal\proc\Entity\Proc::load($proc_id);
    if ($proc) {
      $created[$user_id] = $proc->get('created')->getValue()[0]['value'];  
    }
    else {
      $created[1] = 1;
    }
    
  }

  $form['#attached'] = [
    'library' => [
      0 => 'proc/openpgpjs',
      1 => 'proc/proc-encrypt',
    ],
    'drupalSettings' => [
      'proc' => [
        'proc_labels' => _proc_js_labels(),
        'proc_data'   => $proc_data,
        // @todo: turn this into a configuration:
        'proc_file_entity_max_filesize' => 999999,
        'proc_post_max_size_bytes' => 999999,
        'proc_recipients_pubkeys_changed' => json_encode($created),
        'basePath' => base_path(),
      ]
    ],
  ];
  $current_path = substr($current_path, 1);
  $form_state->set('storage', $selected_user_ids); 
  $form['#action'] = base_path() . $current_path;
}

/**
 * Implements hook_entity_bundle_info_alter().
 */
function proc_entity_bundle_info_alter(array &$bundles): void {
  if (isset($bundles['proc']['proc'])) {
    $bundles['proc']['cipher']['class'] = \Drupal\proc\Entity\Bundle\ProcCipherTextBundle::class;
  }
}

// use Drupal\Core\Field\BaseFieldDefinition;
// use Drupal\Core\Entity\EntityTypeInterface;

/**
 * Implements hook_entity_base_field_info().
 */
// function proc_entity_base_field_info(EntityTypeInterface $entity_type) {
//   // if ($entity_type->id() === 'proc_type' || $entity_type->id() === 'proc') {
//   //   $fields['path'] = BaseFieldDefinition::create('path')
//   //     ->setLabel(t('The path alias'))
//   //     ->setComputed(TRUE);

//   //   return $fields;
//   // }
// }

/**
 * Implements hook_entity_bundle_field_info().
 */
function proc_entity_bundle_field_info(\Drupal\Core\Entity\EntityTypeInterface $entity_type, $bundle, array $base_field_definitions) {
  // if ($entity_type->isFieldable()) {
  //   // Configurable fields, which are always attached to a specific bundle, are
  //   // added 'by bundle'.
  //   return Field::fieldInfo()->getBundleInstances($entity_type->id(), $bundle);
  // }
  // return $entity_type->Field::fieldInfo()->getBundleInstances($entity_type->id(), $bundle);
}

/**
* Implements hook_form_alter().
*/
function proc_form_proc_decrypt_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) {
  // Get cipher IDs from the URL:
  $current_path = \Drupal::service('path.current')->getPath();
  $path_array = explode('/', $current_path);
  $cipher_ids_csv = $path_array[2];
  $cids = _proc_get_csv_argument($cipher_ids_csv);
  // Get 
  $ciphers_data = _proc_common_get_ciphers($cids, FALSE);
  
  // Decryption requires a keyring:
  if (empty($ciphers_data['pubkey'])) {
    \Drupal\proc\Form\ProcDecryptForm::denyAccess();
  }
  
  $common_data = _proc_common_get_decryption_form_data($ciphers_data['privkey']);
  
  $ciphers_changed = [];
  $files_names = [];
  $files_sizes = [];
  foreach($ciphers_data['ciphers'] as $cipher_id_data) {
    $ciphers_changed[] = $cipher_id_data['changed'];
    $files_names[] = $cipher_id_data['source_file_name'];
    $files_sizes[] = $cipher_id_data['source_file_size'];
    // For diferenciating files from text areas:
    $sources_input_mode[] = $cipher_id_data['source_input_mode'];
    $sources_signed[] = $cipher_id_data['signed'];
    
  }
  
  
  $form['#attached'] = [
    'library' => [
      0 => 'proc/openpgpjs',
      1 => 'proc/proc-decrypt',
    ],
    'drupalSettings' => [
      'proc' => [
        'proc_labels'              => _proc_js_labels(),
        'proc_pass'                => $common_data['proc_pass'],
        // 'proc_data'                => $ciphers_data, 
        'proc_privkey'             => $ciphers_data['privkey'],
        'proc_ids'                 => array_keys($ciphers_data['ciphers']),
        'procs_changed'            => $ciphers_changed,
        // Also used for labels on text area encryption:
        'proc_sources_file_names'  => $files_names,
        'proc_sources_file_sizes'  => $files_sizes,
        'proc_sources_input_modes' => $sources_input_mode,
        'proc_sources_signed'      => $sources_signed,
        // @TODO: get this from configuration:
        'proc_skip_size_mismatch'  => 'TRUE',
        'base_path'                => base_path(),
      ]
    ],
  ];
  
  
}

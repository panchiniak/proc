<?php

/**
 * @file
 * Add file system storage of ciphertexts.
 */

include_once 'inc/proc_storage.functions.inc';

/**
 * Implements hook_help().
 */
function proc_storage_help($path) {
  switch ($path) {
    case "admin/help#proc_storage":
      return '<p>' . t('Protected Content Storage enables alternative storage of ciphertexts.') . '</p>';
  }
}

/**
 * Implements hook_permission().
 */
function proc_storage_permission() {
  return [
    'administer proc-storage' => [
      'title' => t('Administer Protected Content Storage'),
      'description' => t('Protected Content Storage settings'),
      'restrict access' => TRUE,
    ],
  ];
}

/**
 * Implements hook_menu().
 */
function proc_storage_menu() {
  $items['admin/config/proc-storage'] = [
    'title' => 'Protected Content Storage Settings',
    'description' => 'Settings of Protected Content Storage',
    'page callback' => 'drupal_get_form',
    'page arguments' => ['_proc_storage_settings_form'],
    'access arguments' => ['administer proc-storage'],
    'file' => 'inc/proc_storage.forms.inc',
  ];
  return $items;
}

/**
 * Implements hook_cipher_serialize_alter().
 */
function proc_storage_cipher_serialize_alter(&$cipher, $context) {
  $proc_storage_placement_settings = _proc_storage_get_placement_settings($cipher, $context);
  // If local storage is enabled:
  if ($proc_storage_placement_settings['proc_storage_enabled'] == 1){
    $proc_storage_stream_wrapper = $proc_storage_placement_settings['proc_storage_global_stream_wrapper'];
    $cipher_md5 = md5($cipher);
    $name_prefix = '';
    if (!empty($proc_storage_placement_settings['proc_storage_file_name_prefix'])) {
      $name_prefix = $proc_storage_placement_settings['proc_storage_file_name_prefix'];
    }
    $json_name = $name_prefix . $cipher_md5 . '.json';
    // Get list of local stream wrapper if more then one is defined:
    $local_stream_wrappers = array_unique(explode(',',$proc_storage_stream_wrapper));

    foreach ($local_stream_wrappers as $local_stream_wrapper_key => $local_stream_wrapper){
      if (file_stream_wrapper_get_instance_by_uri($local_stream_wrapper)){
        // Create the directory if needed:    
        file_prepare_directory($local_stream_wrapper, FILE_CREATE_DIRECTORY);
        if ($file = file_save_data($cipher, $local_stream_wrapper . $json_name)){
          if ($context['unalterable_serialization_source_cid']){
            file_usage_add($file, 'proc_storage', 'proc', $context['unalterable_serialization_source_cid']);
          }
          $file_metadata[] = [
            'cipher_text_fid' => $file->fid,
            'cipher_checksum' => $cipher_md5,
          ];  
        }
      }
      else{
        drupal_set_message(t('A stream wrapper is not registered.'), 'error');
      }
    }
    if (count($file_metadata) > 0){
      $file_metadata_serialized = serialize($file_metadata);

      $cipher = $file_metadata_serialized;  
    }
    else{
      drupal_set_message(t('Unexpected error on saving data. Please verify stream wrapper settings.'), 'error');
    }
  }
  else {
    // We want to store it back in the database if it is not yet there.
    // Therefore, if there was a file usage added, it will be removed:
    if ($context['unalterable_serialization_source_cid']){
      $query = db_select('file_usage', 'fu')
        ->fields('fu', ['fid'])
        ->condition('fu.module', 'proc_storage')
        ->condition('fu.id', $context['unalterable_serialization_source_cid']);
      $fids = $query->execute()->fetchAll();

      if (!empty($fids)){
        $fids_array = [];
        foreach ($fids as $fid){
          $fids_array[] = $fid->fid;
        }
        if ($file_objects = file_load_multiple($fids_array)){
          foreach ($file_objects as $file_object){
            file_usage_delete($file_object, 'proc_storage', NULL, NULL, 1);
          }
        }
      }
    }
    $cipher_data = unserialize($cipher);
  }
}

/**
 * Implements hook_cipher_unserialize_alter().
 */
function proc_storage_cipher_unserialize_alter(&$cipher, $context) {
  if (isset($cipher[0]['cipher_text_fid'])){
    foreach ($cipher as $cipher_copy_key => $cipher_copy){
      if (isset($cipher_copy['cipher_text_fid'])){
        $file_object = file_load($cipher_copy['cipher_text_fid']);
        $data        = file_get_contents($file_object->uri);
        if ($data = file_get_contents($file_object->uri)){
          $md5                           = md5($data);
          $ciphertext_entry_unserialized = unserialize($data);
          $ciphertext                    = $ciphertext_entry_unserialized['cipher_text'];
          $ciphertext_checksum           = $cipher_copy['cipher_checksum'];
          if ($ciphertext_checksum == $md5){
            $cipher = ['cipher_text' => $ciphertext];
            break;      
          }
          else {
            drupal_set_message(t('Error of content integrity.'), 'error');
          }  
        }
        else{
          $availability_error = &drupal_static(__FUNCTION__, []);
          if ($availability_error != TRUE) {

            $content_availability_warning = t(
              'Error of content availability. Trying to access another copy if any. Protected Content ID: <b>@proc-id</b>.',
              [
              '@proc-id' => $context['unalterable_unserialization_source_cid'],
              ]
            );
            drupal_set_message($content_availability_warning, 'warning');

            watchdog(
              'proc_storage',
              'Error accessing protected content: %pid from URI: %uri ',
              [
                '%pid' => $context['unalterable_unserialization_source_cid'],
                '%uri' => $file_object->uri,
              ], WATCHDOG_INFO);

            $availability_error = TRUE;
          }
        }
      }
    }

    if (!isset($cipher['cipher_text'])){
      drupal_set_message(t('All attempts of retrieving the content failled. Possible error in the server\'s file system.'), 'error');
    }    
  }
}

/**
 * Implements hook__action_info().
 */
function proc_storage_action_info() {
  if (variable_get('proc_storage_enabled', 0) == 1){
    $label = t('Update to stream wrapper storage');
  }
  else{
    $label = t('Update to database storage');
  }
  return [
    'proc_storage_switch_action' => [
      'label' => $label,
      'type' => 'proc',
      'configurable' => FALSE,
      'triggers' => ['any'],
      'pass rows' => TRUE,
      'permissions' => ['administer proc-storage'],
    ],
  ];
}

/**
 * Action function for switching stream wrapper based proc storage.
 *
 * @param object $entity
 *   Protected content object.
 * @param array $context
 *   Context of protected content.
 */
function proc_storage_switch_action(&$entity, $context = []) {
  _proc_update_ciphertext($entity->pid, NULL, NULL, NULL);
}

/**
 * Implements form validation
 */
function _proc_storage_settings_form_validate($form, &$form_state) {
  $local_stream_wrappers = array_unique(explode(',',$form_state['values']['proc_storage_global_stream_wrapper']));
  foreach ($local_stream_wrappers as $local_stream_wrapper){
    if (
      !file_stream_wrapper_get_instance_by_uri($local_stream_wrapper) ||
      (substr($local_stream_wrapper, -1) != '/')
    ){
      form_set_error('proc_storage_global_stream_wrapper', t(
        'Stream wrapper <b>@invalid-stream-wrapper</b> is invalid.',
        [
          '@invalid-stream-wrapper' => $local_stream_wrapper,
          ]
      ));
    }
  }
}

/**
 * Implements hook_cipher_postsave()
 */
function proc_storage_cipher_postsave($pid, $form_state, $entity){
  $proc_storage_placement_settings = _proc_storage_get_placement_settings($entity, $form_state);
  if (isset($pid) && $proc_storage_placement_settings['proc_storage_enabled'] == 1){
    if (
      $cid = unserialize($entity->proc_armored[LANGUAGE_NONE][0]['value'])[0]['cipher_text_fid'] &&
      $file_object = file_load(unserialize($entity->proc_armored[LANGUAGE_NONE][0]['value'])[0]['cipher_text_fid'])
    ){
      if (!file_usage_list($file_object)){
        file_usage_add($file_object, 'proc_storage', 'proc', $pid, 1);
      }
    }
  }
}

<?php

/**
 * @file
 * Set up a structure for storing pgp keys and cipher texts.
 */

include_once 'inc/proc.functions.inc';

/**
 * Implements hook_schema().
 */
function proc_schema() {
  $schema = array();

  $schema['proc'] = array(
    'description' => 'The base table for proc.',
    'fields' => array(
      // Armored ID:
      'pid' => array(
        'description' => 'Armored entity primary identifier.',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'uid' => array(
        'description' => 'User id from the users table.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
      'title' => array(
        'description' => 'The title of this protectec content.',
        'type' => 'text',
        'size' => 'small',
      ),
      'status' => array(
        'description' => 'Boolean indicating whether the proc is published (visible to non-administrators).',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 1,
      ),
      'type' => array(
        'description' => 'Entity instance type.',
        'type' => 'text',
        'size' => 'medium',
      ),
      'created' => array(
        'description' => 'The Unix timestamp when the armored was created.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
    ),
    'primary key' => array('pid'),
  );

  return $schema;
}

/**
 * Implements hook_modules_enabled().
 */
function proc_modules_enabled($modules) {
  if (in_array('proc', $modules)) {

    $fields = array(
      'proc_armored' => array(
        'field_name' => 'proc_armored',
        'type' => 'text_long',
        'size' => 'big',
      ),
      'proc_recipient' => array(
        'field_name' => 'proc_recipient',
        'type' => 'entityreference',
        'cardinality' => FIELD_CARDINALITY_UNLIMITED,
        'settings' => array(
          'target_type' => 'user',
          'target_bundles' => array('user'),
        ),
      ),
      'proc_armoredown' => array(
        'field_name' => 'proc_armoredown',
        'type' => 'entityreference',
        'cardinality' => 1,
        'settings' => array(
          'target_type' => 'user',
          'target_bundles' => array('user'),
        ),
      ),
    );
    _proc_field_create_fields($fields);

    $instances = array(
      'armored_keyring' => array(
        'field_name' => 'proc_armored',
        'label' => t('Serialized data of proc_keyring bundle'),
        'entity_type' => 'proc',
        'bundle' => 'proc_keyring',
      ),
      'armoredowner_keyring' => array(
        'field_name' => 'proc_armoredown',
        'label' => t('Owner of protected content keyring'),
        'entity_type' => 'proc',
        'bundle' => 'proc_keyring',
      ),
      'armoredowner_ciphertext' => array(
        'field_name' => 'proc_armoredown',
        'label' => t('Owner of protected content cipher text'),
        'entity_type' => 'proc',
        'bundle' => 'proc_ciphertxt',
      ),
      'armored_ciphertext' => array(
        'field_name' => 'proc_armored',
        'label' => t('Serialized data of proc_ciphertxt bundle'),
        'entity_type' => 'proc',
        'bundle' => 'proc_ciphertxt',
      ),
      'recipient_ciphertxt' => array(
        'field_name' => 'proc_recipient',
        'entity_type' => 'proc',
        'bundle' => 'proc_ciphertxt',
        'label' => t('Ciphertext recipient user reference'),
      ),
    );
    _proc_field_create_instances($instances);
  }
}

/**
 * Implements hook_uninstall().
 */
function proc_uninstall() {
  // Delete previously created field.
  field_delete_field('proc_armored');
  field_delete_field('proc_recipient');
  field_delete_field('proc_armoredown');
  field_purge_batch(0);
}

/**
 * Remove empty key entries if any.
 */
function proc_update_7000() {
  $query = db_query(
    'SELECT p.entity_id, p.proc_armored_value FROM {field_data_proc_armored} p WHERE bundle = :type', [
      ':type' => 'proc_keyring',
    ]
  );
  $recorded_key_entries = $query->fetchAll();
  // For each key:
  foreach ($recorded_key_entries as $recorded_key_entry) {
    // If key has been saved empty:
    if (strpos($recorded_key_entry->proc_armored_value, '"public_key";s:0:""') == TRUE) {
      watchdog('proc', 'Deleting empty key entry pid: %pid', array('%pid' => $recorded_key_entry->entity_id), WATCHDOG_INFO);
      try {
        entity_delete('proc', $recorded_key_entry->entity_id);
      }
      catch (Exception $e) {
        watchdog_exception('proc', $e);
      }
    }
  }
}
